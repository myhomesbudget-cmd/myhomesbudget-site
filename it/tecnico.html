// DASHBOARD RIEPILOGO - INTEGRAZIONE DATI REALI SUPABASE
// Basato sulla struttura del dashboard principale

window.DashboardRiepilogoData = {
    user: null,
    
    async initialize() {
        try {
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) {
                console.error('Utente non autenticato');
                return false;
            }
            this.user = user;
            return true;
        } catch (error) {
            console.error('Errore inizializzazione:', error);
            return false;
        }
    },

    async loadSummaryData(selectedMonth, selectedYear, currentView = 'monthly') {
        if (!this.user) {
            throw new Error('Utente non autenticato');
        }

        let startDate, endDate;
        if (currentView === 'annual') {
            startDate = new Date(selectedYear, 0, 1);
            endDate = new Date(selectedYear, 11, 31, 23, 59, 59);
        } else {
            startDate = new Date(selectedYear, selectedMonth, 1);
            endDate = new Date(selectedYear, parseInt(selectedMonth) + 1, 0, 23, 59, 59);
        }

        try {
            // Carica dati paralleli da Supabase
            const [transactionsRes, budgetRes, goalRes, allTransRes] = await Promise.all([
                // Transazioni del periodo
                supabase.from('transactions')
                    .select('*, categories(name, icon)')
                    .eq('created_by', this.user.id)
                    .gte('occurred_at', startDate.toISOString())
                    .lte('occurred_at', endDate.toISOString())
                    .eq('is_paid', true),
                
                // Budget risparmi piÃ¹ recente
                supabase.from('budgets')
                    .select('amount')
                    .eq('user_id', this.user.id)
                    .eq('macro_category', 'Risparmi')
                    .order('month', { ascending: false })
                    .limit(1)
                    .maybeSingle(),
                
                // Obiettivo attivo
                supabase.from('goals')
                    .select('name, target_amount, current_amount')
                    .eq('user_id', this.user.id)
                    .eq('active', true)
                    .limit(1)
                    .maybeSingle(),
                
                // Tutte le transazioni storiche
                supabase.from('transactions')
                    .select('kind, amount, occurred_at')
                    .eq('created_by', this.user.id)
                    .lte('occurred_at', new Date().toISOString())
            ]);

            // Verifica errori
            const errors = [transactionsRes.error, budgetRes.error, goalRes.error, allTransRes.error].filter(Boolean);
            if (errors.length > 0) {
                console.error('Errori nel caricamento:', errors);
                throw new Error('Errore nel caricamento dei dati');
            }

            // Elabora i dati
            const transactions = transactionsRes.data || [];
            const monthlySavingGoal = budgetRes.data ? this.safeToNumber(budgetRes.data.amount) : 0;
            const goalData = goalRes.data;
            const allTransactions = allTransRes.data || [];

            // Calcola statistiche
            const incomeTransactions = transactions.filter(t => t.kind === 'income');
            const expenseTransactions = transactions.filter(t => t.kind === 'expense');
            
            const totalIncome = incomeTransactions.reduce((sum, t) => sum + this.safeToNumber(t.amount), 0);
            const totalExpenses = expenseTransactions.reduce((sum, t) => sum + this.safeToNumber(t.amount), 0);
            
            // Raggruppa spese per categoria
            const categoryExpenses = {};
            expenseTransactions.forEach(tx => {
                const categoryName = tx.categories?.name || 'Altro';
                const categoryIcon = tx.categories?.icon || 'ðŸ’¸';
                if (!categoryExpenses[categoryName]) {
                    categoryExpenses[categoryName] = { 
                        name: categoryName, 
                        icon: categoryIcon, 
                        amount: 0
                    };
                }
                categoryExpenses[categoryName].amount += this.safeToNumber(tx.amount);
            });

            // Top 5 categorie di spesa
            const topCategories = Object.values(categoryExpenses)
                .sort((a, b) => b.amount - a.amount)
                .slice(0, 5);

            // Transazioni recenti
            const recentTransactions = transactions
                .sort((a, b) => new Date(b.occurred_at) - new Date(a.occurred_at))
                .slice(0, 10)
                .map(tx => ({
                    date: new Date(tx.occurred_at).toLocaleDateString('it-IT'),
                    description: tx.note || 'Transazione',
                    amount: tx.kind === 'income' ? this.safeToNumber(tx.amount) : -this.safeToNumber(tx.amount),
                    category: tx.categories?.name || 'Altro',
                    icon: tx.categories?.icon || (tx.kind === 'income' ? 'ðŸ’°' : 'ðŸ’¸')
                }));

            return {
                monthlyIncome: totalIncome,
                monthlyExpenses: totalExpenses,
                balance: totalIncome - totalExpenses,
                savingsTarget: goalData ? this.safeToNumber(goalData.target_amount) : 0,
                currentSavings: goalData ? this.safeToNumber(goalData.current_amount) : 0,
                goalName: goalData?.name || 'Nessun obiettivo',
                monthlySavingGoal,
                categories: topCategories,
                recentTransactions,
                totalTransactions: transactions.length,
                period: {
                    month: selectedMonth,
                    year: selectedYear,
                    view: currentView
                }
            };

        } catch (error) {
            console.error('Errore nel caricamento dei dati:', error);
            throw error;
        }
    },

    safeToNumber(v) {
        const n = (typeof v === 'number') ? v : parseFloat(String(v).replace(',', '.'));
        return Number.isFinite(n) ? n : 0;
    },

    formatCurrency(amount) {
        return new Intl.NumberFormat('it-IT', {
            style: 'currency',
            currency: 'EUR',
            minimumFractionDigits: 2
        }).format(amount);
    }
};

console.log('Dashboard Riepilogo Data module loaded');
